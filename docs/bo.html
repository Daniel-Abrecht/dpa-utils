<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" type="text/css" href="css/style.css" />
  <title>DAP-Utils - Buffer Object (BO)</title>
</head>
<body id="top"><section>
  <h1><a href="#top">DAP-Utils - Buffer Object (BO)</a></h1>
  <section>
    <h2 id="types"><a href="#types">Types</a></h2>
    <section>
      <h3 id="dpa_u_a_bo_"><a href="#dpa_u_a_bo_">Tagged BO pointers - <var>dpa_u_a_bo_*</var></a></h2>
      <figure>
        <figcaption>The following tagged poiter types exist:</figcaption>
        <table class="first-right striped pad">
          <tbody>
            <tr id="dpa_u_a_bo_any_t">
              <th><a class="var" href="#dpa_u_a_bo_any_t">dpa_u_a_bo_any_t</a></th>
              <td>The BO can refer to any kind of data, and can have any valid tag</td>
            </tr><tr id="dpa_u_a_bo_gc_t">
              <th><a class="var" href="#dpa_u_a_bo_gc_t">dpa_u_a_bo_gc_t</a></th>
              <td>The BO can contain unique, refcounted and static data</td>
            </tr><tr id="dpa_u_a_bo_unique_t">
              <th><a class="var" href="#dpa_u_a_bo_unique_t">dpa_u_a_bo_unique_t</a></th>
              <td>This tagged BO pointer has an unique value. Data smaller than 8 bytes will be inlined. Unused bytes will be 0.</td>
            </tr>
          </tbody>
        </table>
      </figure>
      <figure>
        <figcaption>
          The tag of a tagged BO Pointer consists of a set of types, and in the case of an inline BO, the size of the data.<br>
          The following Tags exist:
        </figcaption>
        <table class="first-right striped pad">
          <thead>
            <th colspan="2">enum dpa_u_bo_type_flags</th>
          </thead>
          <tbody>
            <tr id="DPA_U_BO_SIMPLE">
              <th><a class="var" href="#DPA_U_BO_SIMPLE">DPA_U_BO_SIMPLE</a></th>
              <td>
                If this tag is set, the pointer points to a dpa_u_bo_t object.
                Except for inlined data, this is always the case.
              </td>
            </tr><tr id="DPA_U_BO_STATIC">
              <th><a class="var" href="#DPA_U_BO_STATIC">DPA_U_BO_STATIC</a></th>
              <td>The data has static lifetime. The data will never be freed.</td>
            </tr><tr id="DPA_U_BO_REFCOUNTED">
              <th><a class="var" href="#DPA_U_BO_REFCOUNTED">DPA_U_BO_REFCOUNTED</a></th>
              <td>
                The data has a reference count. This is never an inline BO.
              </td>
            </tr><tr id="DPA_U_BO_UNIQUE">
              <th><a class="var" href="#DPA_U_BO_UNIQUE">DPA_U_BO_UNIQUE</a></th>
              <td>
                The data of this BO is unique. The BO itself is refcounted. The BO and it's data are immutable, they
                will not change.<br/>
                The data may or may not have it's own refcount, and it may or may not store it's hash, and this may
                change depending on the data and between implementations.
              </td>
            </tr><tr id="DPA_U_BO_HASHED">
              <th><a class="var" href="#DPA_U_BO_HASHED">DPA_U_BO_HASHED</a></th>
              <td>
                The BO is pre-hashed.
              </td>
            </tr>
          </tbody>
        </table>
      </figure>
      <p>
        All <a class="var" href="#dpa_u_a_bo_">dpa_u_a_bo_*</a> objects represent either tagged BO pointers, or inlined data.
        Inlined data can be at most 7 bytes big. The first byte is reserved for the tag of the tagged BO pointer. The tag
        contains information about the type of object it points to, and the lifetime of the data the BO refers to,
        but the lifetime of the BO object itself may differ from that. The tag also contains the length of inline data
        if it is an inline BO.<br/>
        If a tagged BO pointer is dereferenced, the resulting BO object will be const qualified.
      </p>
      <p>
        A tagged BO pointer without any tags represents an error value. An error value is an inline BO object which is not
        marked as unique. In other words, it can be safely dereferenced, and then contains the name of the error. However,
        it is recommended to actually check if a tagged BO pointer is an error object, using the
        <a class="var" href="#dpa_u_bo_is_error">dpa_u_bo&shy;_is_error</a> function.
      </p>
    </section>
    <section>
      <h3 id="dpa_u_bo_"><a href="#dpa_u_bo_">BO Types - <var>dpa_u_bo_*</var></a></h2>
      <p>
        Currently, only the simple <a class="var" href="#dpa_u_bo_t">dpa_u_bo_t</a> type is implemented.
        There are internal types for hashed and refcounted BOs, but there are no plans to expose them as of now.
        This is because there is no way to define a hashed refcounted bo in such a way that a pointer to it can be
        converted to both, a hashed bo and a refcounted bo, without type-punning, which would be UB.<br/>
        There are tagged pointers for hashed and refcounted BOs, and functions for creating them in the current block
        scope, as well as functions for getting the refcount and the hash.
      </p>
      <section class="nocolumn">
        <h4 id="dpa_u_bo_t"><a class="var" href="#dpa_u_bo_t">dpa_u_bo_t</a></h4>
        <table class="pad first-right striped">
          <tr><th>Type</th><th>Name</th><th>Description</th></tr>
          <tr><td><nobr>size_t</td><td>size</td><td>The size of the BO.</td></tr>
          <tr><td><nobr>const char*</td><td>data</td><td>A pointer to the data</td></tr>
        </table>
      </section>
    </section>
  </section>
  <section>
    <h2 id="object_lifetimes"><a href="#object_lifetimes">Object lifetimes</a></h2>
    <p>
      The lifetime of BO objects may be shorter than that of the data. The only exception are inline BOs.
      The lifetime of an inline BO always matches that of the tagged BO pointer value itself. <br/>
      Special care must be taken when passing a refcounted BO which is not a unique BO to another function, or when
      storing it in a shared object. In that case only the data is refcounted, and multiple refcounted BO objects
      referencing the same data with shorter lifetimes could exist. Unlike with unique BOs, incrementing the refcount
      is insufficient in this case, BO objects of sufficient lifetime must be created.
    </p><p>
      When storing, for example, a <a class="var" href="#dpa_u_a_bo_gc_t">dpa_u_a_bo_gc_t</a> in a shared object, when
      it is not known if the BO has a sufficient lifetime, a new BO Object needs to be allocated. The functions
      <a class="var" href="#dpa_u_bo_copy_maybe">dpa_u_bo&shy;_copy_&shy;maybe</a> and
      <a class="var" href="#dpa_u_bo_copy_bo_maybe">dpa_u_bo&shy;_copy&shy;_bo&shy;_maybe</a> exist to help with that.
    </p><p>
      As a convention, functions will assume that the BOs tagged pointers point to, and their data, are immutable.
      They may store them under that assumption. However, this doesn't always have to be the case. If the BO or it's
      data is not immutable, it may be necessarey to copy it in that case. The function
      <a class="var" href="#dpa_u_bo_needs_copy">dpa_u_bo_needs_copy</a> can be used to force a BO to be copied later
      if necessary.
    </p>
  </section>
  <section>
    <h2 id="functions"><a href="#functions">Functions</a></h2>
    <section>
      <h3 id="dpa_u_bo_copy_maybe"><a class="var" href="#dpa_u_bo_copy_maybe">dpa_u_bo&shy;_copy&shy;_maybe</a></h1>
      If the BO is a unique BO, this function just increments the BOs refcount.
      Otherwise a new BO object is allocated.
      The refcount of the data of a refcounted BO is also incremented, in addition to a new BO object being allocated.
      If a BO is neither unique, nor refcounted, nor static, the data is also copied.
    </section>
    <section>
      <h3 id="dpa_u_bo_copy_bo_maybe"><a class="var" href="#dpa_u_bo_copy_bo_maybe">dpa_u_bo&shy;_copy&shy;_bo&shy;_maybe</a></h1>
      Unlike <a class="var" href="#dpa_u_bo_copy_maybe">dpa_u_bo&shy;_copy&shy;_maybe</a>, this function does not copy the BOs
      data. Everything else is the same. Only use this function if the data is known to have a sufficient lifetime.
    </section>
    <section>
      <h3 id="dpa_u_bo_ref"><a class="var" href="#dpa_u_bo_ref">dpa_u_bo&shy;_ref</a></h1>
      If it is a unique BO, only the unique BOs refcount is incremented.
      Otherwise the datas refcount is incremented. If there is no refcount, nothing happens.
      This function is thread safe.
    </section>
    <section>
      <h3 id="dpa_u_bo_put"><a class="var" href="#dpa_u_bo_put">dpa_u_bo&shy;_put</a></h1>
      If it is a unique BO, only the unique BOs refcount is decremented.
      Otherwise the datas refcount is decremented.
      If the refcount hits 0, the data is freed. If it is a unique BO, the unique BO is removed from the set of unique BOs,
      and the refcount of the data is decremented if there is one, and freed once nothing references it anymore.
      This function is thread safe.
    </section>
    <section>
      <h3 id="dpa_u_bo_is_error"><a class="var" href="#dpa_u_bo_is_error">dpa_u_bo&shy;_is_error</a></h1>
      Takes a tagged BO pointer. If it is an error object, returns true. Otherwise, it returns false.
    </section>
    <section>
      <h3 id="dpa_u_bo_error"><a class="var" href="#dpa_u_bo_error">dpa_u_bo&shy;_error</a></h1>
      Takes an errno value, returns a <a class="var" href="#dpa_u_a_bo_unique_t">dpa_u_a_bo&shy;_unique_t</a>.
      The BO object will not be a unique bo, though, but an error object.
    </section>
    <section>
      <h3 id="dpa_u_bo_error_to_errno"><a class="var" href="#dpa_u_bo_error_to_errno">dpa_u_bo&shy;_error&shy;_to_errno</a></h1>
      Takes an error object. If it corrensponds to a known errno value, that value is returned. Otherwiese, -1 is returned.
    </section>
    <section>
      <h3 id="dpa_u_bo_equal"><a class="var" href="#dpa_u_bo_equal">dpa_u_bo&shy;_equal</a></h1>
      <p>
        Returns true if the BOs have the same size &amp; data, false otherwise.
      </p>
    </section>
    <section>
      <h3 id="dpa_u_bo_compare"><a class="var" href="#dpa_u_bo_compare">dpa_u_bo&shy;_compare</a></h1>
      <p>
        Returns 0 if the BOs have the same size &amp; data. Returns a positive or negative value otherwise.
        If both BOs are unique BOs, only the pointers are compared. Otherwise, the size and data is compared.
        This function can be used for sorting BOs, so long as unique and non-unique BOs are not mixed.
        If there are unique and non-unique BOs, use <a class="var" href="#dpa_u_bo_compare_data">dpa_u_bo&shy;_compare&shy;_data</a>
        instead.
      </p>
    </section>
    <section>
      <h3 id="dpa_u_bo_compare_data"><a class="var" href="#dpa_u_bo_compare_data">dpa_u_bo&shy;_compare_data</a></h1>
      <p>
        Returns 0 if the BOs have the same size &amp; data. Returns a positive or negative value otherwise. Can be used
        for sorting. It first compares the size, then the data using memcmp, that is the order qa sort is going to have.
      </p>
    </section>
    <section>
      <h3 id="conversion_functions"><a href="#conversion_functions">Conversion Functions</a></h2>
      <section>
        <h4 id="dpa_u_bo_intern"><a class="var" href="#dpa_u_bo_intern">dpa_u_bo&shy;_intern</a></h1>
        <p>
          Interns a BO. Returns a unique BO. If the data is refcounted or static, it may not copy it, but just increment
          the refcount instead. When passing a refcounted BO to this function, make sure it's data is immutable.
          To force the data to be copied, use the <a class="var" href="#dpa_u_bo_untag_gc"> dpa_u_bo&shy;_untag&shy;_gc
          </a> function.
          This function is thread safe.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_to_bo"><a class="var" href="#dpa_u_to_bo">dpa_u_to_bo</a></h1>
        <p>
          Returns an lvalue reference to the BO.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_to_bo_any"><a class="var" href="#dpa_u_to_bo_any">dpa_u_to_bo_any</a></h1>
        <p>
          Returns a <a class="var" href="#dpa_u_a_bo_any_t">dpa_u_a_bo&shy;_any_t</a> to the specified BO.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_to_bo_any_static"><a class="var" href="#dpa_u_to_bo_any_static">dpa_u_to_bo_any_static</a></h1>
        <p>
          Returns a <a class="var" href="#dpa_u_a_bo_any_t">dpa_u_a_bo&shy;_any_t</a> to the specified BO.
          It is tagged as a static BO.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_to_bo_gc"><a class="var" href="#dpa_u_to_bo_gc">dpa_u_to_bo_gc</a></h1>
        <p>
          Returns a <a class="var" href="#dpa_u_a_bo_gc_t">dpa_u_a_bo&shy;_gc_t</a> to the specified BO.
          If the conversion isn't allowed at runtime, an error object will be returned.
          The BO to be converted must be refcounted, static, inline, unique, or a combination of those things.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_to_bo_gc_static"><a class="var" href="#dpa_u_to_bo_gc_static">dpa_u_to_bo_gc_static</a></h1>
        <p>
          Takes a <a class="var" href="#dpa_u_bo_t">dpa_u_bo_t</a>.
          Returns a <a class="var" href="#dpa_u_a_bo_gc_t">dpa_u_a_bo&shy;_gc_t</a> to the specified BO.
          It is tagged as a static BO.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_make_bo_any_with_refcount"><a class="var" href="#dpa_u_make_bo_any_with_refcount">dpa_u_make_bo_any_with_refcount</a></h1>
        <p>
          Takes a <a class="var" href="#dpa_u_bo_t">dpa_u_bo_t</a> and a pointer to a
          <a class="var" href="refcount.html#dpa_u_refcount_freeable_t">dpa_u&shy;_refcount&shy;_freeable_t</a>.
          Creates a new BO object in the current block scope with a pointer to a refcount. If the refcount
          is static, it may be omited, and the BO pointer is tagged as static instead.
          Returns a <a class="var" href="#dpa_u_a_bo_any_t">dpa_u_a_bo&shy;_any_t*</a>.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_make_bo_any_with_hash"><a class="var" href="#dpa_u_make_bo_any_with_hash">dpa_u_make_bo_any_with_hash</a></h1>
        <p>
          Takes a <a class="var" href="#dpa_u_bo_t">dpa_u_bo_t</a> and a uint64_t containing the hash.
          The hash must be the same as would have been calculated using the <a class="var" href="#dpa_u_bo_get_hash">
          dpa_u_bo&shy;_get&shy;_hash</a> function.
          Creates a new BO object in the current block scope with a hash.
          Returns a <a class="var" href="#dpa_u_a_bo_any_t">dpa_u_a_bo&shy;_any_t*</a>.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_make_bo_any_static_with_hash"><a class="var" href="#dpa_u_make_bo_any_static_with_hash">dpa_u_make_bo_any_static_with_hash</a></h1>
        <p>
          Takes a <a class="var" href="#dpa_u_bo_t">dpa_u_bo_t</a> and a uint64_t containing the hash.
          The hash must be the same as would have been calculated using the <a class="var" href="#dpa_u_bo_get_hash">
          dpa_u_bo&shy;_get&shy;_hash</a> function.
          Creates a new BO object in the current block scope with a hash.
          The tagged BO pointer has the static flag set.
          Returns a <a class="var" href="#dpa_u_a_bo_any_t">dpa_u_a_bo&shy;_any_t*</a>.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_make_bo_any_with_refcount_hash"><a class="var" href="#dpa_u_make_bo_any_with_refcount_hash">dpa_u_make_bo_any_with_refcount_hash</a></h1>
        <p>
          Takes a <a class="var" href="#dpa_u_bo_t">dpa_u_bo_t</a>, a pointer to a
          <a class="var" href="refcount.html#dpa_u_refcount_freeable_t">dpa_u&shy;_refcount&shy;_freeable_t</a> and a
          uint64_t containing the hash.
          The hash must be the same as would have been calculated using the <a class="var" href="#dpa_u_bo_get_hash">
          dpa_u_bo&shy;_get&shy;_hash</a> function.
          Creates a new BO object in the current block scope with a pointer to a refcount and a hash. If the refcount
          is static, it may be omited, and the BO pointer is tagged as static instead.
          Returns a <a class="var" href="#dpa_u_a_bo_any_t">dpa_u_a_bo&shy;_any_t*</a>.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_make_bo_gc_with_refcount"><a class="var" href="#dpa_u_make_bo_gc_with_refcount">dpa_u_make_bo_gc_with_refcount</a></h1>
      </section>
      <section>
        <h4 id="dpa_u_make_bo_gc_static_with_hash"><a class="var" href="#dpa_u_make_bo_gc_static_with_hash">dpa_u_make_bo_gc_static_with_hash</a></h1>
      </section>
      <section>
        <h4 id="dpa_u_make_bo_gc_with_refcount_hash"><a class="var" href="#dpa_u_make_bo_gc_with_refcount_hash">dpa_u_make_bo_gc_with_refcount_hash</a></h1>
      </section>
      <section>
        <h4 id="dpa_u_bo_unique_to_uint"><a class="var" href="#dpa_u_bo_unique_to_uint">dpa_u_bo&shy;_unique_to_uint</a></h1>
      </section>
      <section>
        <h4 id="dpa_u_bo_unique_from_uint"><a class="var" href="#dpa_u_bo_unique_from_uint">dpa_u_bo&shy;_unique_from_uint</a></h1>
      </section>
    </section>
    <section>
      <h3 id="tagging_functions"><a href="#tagging_functions">Pointer tagging functions</a></h2>
      <section>
        <h4 id="dpa_u_bo_needs_copy"><a class="var" href="#dpa_u_bo_needs_copy">dpa_u_bo_needs_copy</a></h1>
        <p>
          In case of a <a class="var" href="#dpa_u_a_bo_unique_t">dpa_u_a_bo_unique_t</a>, this does nothing, the same
          pointer is returned.
          Otherwise, it removes refcounted and static BO pointer tags, and returns a
          <a class="var" href="#dpa_u_a_bo_any_t">dpa_u_a_bo&shy;_any_t</a> tag.
          This is useful if the BO may change later, but the function it is passed to may store it but shouldn't be
          affected by the changes to the BO. Removing these tags forces the BO to be copied in that case if necessary.
        </p>
      </section>
    </section>
    <section>
      <h3 id="member_functions"><a href="#member_functions">Member access Functions</a></h2>
      <section>
        <h4 id="dpa_u_bo_get_data"><a class="var" href="#dpa_u_bo_get_data">dpa_u_bo_get_data</a></h1>
        <p>
          Returns a pointer to the BOs data.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_bo_get_size"><a class="var" href="#dpa_u_bo_get_size">dpa_u_bo_get_size</a></h1>
        <p>
          Get the size of the BO.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_bo_get_hash"><a class="var" href="#dpa_u_bo_get_hash">dpa_u_bo_get_hash</a></h1>
        <p>
          Get the hash of the BO. If the BO doesn't have a hash pre-calculated, it calculates the hash.
        </p>
      </section>
      <section>
        <h4 id="dpa_u_bo_get_refcount"><a class="var" href="#dpa_u_bo_get_refcount">dpa_u_bo_get_refcount</a></h1>
        <p>
          Returns a pointer to a <a class="var" href="refcount.html#dpa_u_refcount_freeable_t">dpa_u&shy;_refcount&shy;_freeable_t</a>.
          If it is a unique BO, this is the refcount of the BO object. Otherwise, it is only the refcount of the data.
          Returns 0 if there is no refcount, including if there is a unique BO.
        </p>
      </section>
    </section>
  </section>
</section></body></html>
